package rickandmorty

// Code generated by graphql-codegen-golang ; DO NOT EDIT.

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"
)

type Client struct {
	*http.Client
	Url string
}

// NewClient creates a GraphQL client ready to use.
func NewClient(url string) *Client {
	return &Client{
		Client: &http.Client{},
		Url:    url,
	}
}

type GraphQLOperation struct {
	Query         string          `json:"query"`
	OperationName string          `json:"operationName,omitempty"`
	Variables     json.RawMessage `json:"variables,omitempty"`
}

type GraphQLResponse struct {
	Data   json.RawMessage `json:"data,omitempty"`
	Errors []GraphQLError  `json:"errors,omitempty"`
}

type GraphQLError map[string]interface{}

func (err GraphQLError) Error() string {
	return fmt.Sprintf("graphql: %v", map[string]interface{}(err))
}

func (resp *GraphQLResponse) Error() string {
	if len(resp.Errors) == 0 {
		return ""
	}
	errs := strings.Builder{}
	for _, err := range resp.Errors {
		errs.WriteString(err.Error())
		errs.WriteString("\n")
	}
	return errs.String()
}

func execute(client *http.Client, req *http.Request) (*GraphQLResponse, error) {
	if client == nil {
		client = http.DefaultClient
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	body, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, err
	}
	return unmarshalGraphQLReponse(body)
}

func unmarshalGraphQLReponse(b []byte) (*GraphQLResponse, error) {
	resp := GraphQLResponse{}
	if err := json.Unmarshal(b, &resp); err != nil {
		return nil, err
	}
	if len(resp.Errors) > 0 {
		return &resp, &resp
	}
	return &resp, nil
}

type CharacterFragment struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

//
// query GetCharacters($page: Int)
//

type GetCharactersVariables struct {
	Page *Int `json:"page,omitempty"`
}

type GetCharactersResponse struct {
	Characters struct {
		Results *[]struct {
			CharacterFragment
		} `json:"results"`
	} `json:"characters"`
}

type GetCharactersRequest struct {
	*http.Request
}

func NewGetCharactersRequest(url string, vars *GetCharactersVariables) (*GetCharactersRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `query GetCharacters($page: Int) {
  characters(page: $page) {
    results {
      ...CharacterFragment
    }
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &GetCharactersRequest{req}, nil
}

func (req *GetCharactersRequest) Execute(client *http.Client) (*GetCharactersResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result GetCharactersResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func GetCharacters(url string, client *http.Client, vars *GetCharactersVariables) (*GetCharactersResponse, error) {
	req, err := NewGetCharactersRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) GetCharacters(vars *GetCharactersVariables) (*GetCharactersResponse, error) {
	return GetCharacters(client.Url, client.Client, vars)
}

//
// Scalars
//

type Int int32
type Float float64
type Boolean bool
type String string
type ID string
type Upload string

//
// Enums
//

type CacheControlScope string

const (
	CacheControlScopePUBLIC  CacheControlScope = "PUBLIC"
	CacheControlScopePRIVATE CacheControlScope = "PRIVATE"
)

//
// Inputs
//

type FilterCharacter struct {
	Name    *String `json:"name,omitempty"`
	Status  *String `json:"status,omitempty"`
	Species *String `json:"species,omitempty"`
	Type    *String `json:"type,omitempty"`
	Gender  *String `json:"gender,omitempty"`
}

type FilterLocation struct {
	Name      *String `json:"name,omitempty"`
	Type      *String `json:"type,omitempty"`
	Dimension *String `json:"dimension,omitempty"`
}

type FilterEpisode struct {
	Name    *String `json:"name,omitempty"`
	Episode *String `json:"episode,omitempty"`
}

//
// Objects
//

type Query struct {
	Character       *Character   `json:"character,omitempty"`
	Characters      *Characters  `json:"characters,omitempty"`
	CharactersByIds *[]Character `json:"charactersByIds,omitempty"`
	Location        *Location    `json:"location,omitempty"`
	Locations       *Locations   `json:"locations,omitempty"`
	LocationsByIds  *[]Location  `json:"locationsByIds,omitempty"`
	Episode         *Episode     `json:"episode,omitempty"`
	Episodes        *Episodes    `json:"episodes,omitempty"`
	EpisodesByIds   *[]Episode   `json:"episodesByIds,omitempty"`
}

type Character struct {
	ID       *ID       `json:"id,omitempty"`
	Name     *String   `json:"name,omitempty"`
	Status   *String   `json:"status,omitempty"`
	Species  *String   `json:"species,omitempty"`
	Type     *String   `json:"type,omitempty"`
	Gender   *String   `json:"gender,omitempty"`
	Origin   *Location `json:"origin,omitempty"`
	Location *Location `json:"location,omitempty"`
	Image    *String   `json:"image,omitempty"`
	Episode  []Episode `json:"episode"`
	Created  *String   `json:"created,omitempty"`
}

type Location struct {
	ID        *ID         `json:"id,omitempty"`
	Name      *String     `json:"name,omitempty"`
	Type      *String     `json:"type,omitempty"`
	Dimension *String     `json:"dimension,omitempty"`
	Residents []Character `json:"residents"`
	Created   *String     `json:"created,omitempty"`
}

type Episode struct {
	ID         *ID         `json:"id,omitempty"`
	Name       *String     `json:"name,omitempty"`
	AirDate    *String     `json:"air_date,omitempty"`
	Episode    *String     `json:"episode,omitempty"`
	Characters []Character `json:"characters"`
	Created    *String     `json:"created,omitempty"`
}

type Characters struct {
	Info    *Info        `json:"info,omitempty"`
	Results *[]Character `json:"results,omitempty"`
}

type Info struct {
	Count *Int `json:"count,omitempty"`
	Pages *Int `json:"pages,omitempty"`
	Next  *Int `json:"next,omitempty"`
	Prev  *Int `json:"prev,omitempty"`
}

type Locations struct {
	Info    *Info       `json:"info,omitempty"`
	Results *[]Location `json:"results,omitempty"`
}

type Episodes struct {
	Info    *Info      `json:"info,omitempty"`
	Results *[]Episode `json:"results,omitempty"`
}
